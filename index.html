<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Flower Experience</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
        }
        
        #nameInput {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #ff5252;
        }
        
        #vrButton {
            background: #4ecdc4;
        }
        
        #vrButton:hover {
            background: #26a69a;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h2>ðŸŒ¸ VR Flower Experience</h2>
        <input type="text" id="nameInput" placeholder="Enter name for flower letters" value="LOVE">
        <br>
        <button onclick="createFlowerName()">Create Flower Letters</button>
        <button onclick="createFlowerHeart()">Create Flower Heart</button>
        <button id="vrButton" onclick="enterVR()">Enter VR Mode</button>
    </div>
    
    <div id="instructions">
        <strong>Instructions:</strong><br>
        â€¢ Enter a name and click "Create Flower Letters" for a floral text display<br>
        â€¢ Click "Create Flower Heart" for a walkable heart structure<br>
        â€¢ Use WASD to move, mouse to look around<br>
        â€¢ Click "Enter VR Mode" on Meta Quest 2 for immersive experience
    </div>

    <script>
        let scene, camera, renderer, flowers = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Initialize the scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add ground
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Setup controls
            setupControls();
            
            // Start render loop
            animate();
            
            // Create initial flower heart
            createFlowerHeart();
        }
        
        function createFlower(x, y, z, scale = 1) {
            const flowerGroup = new THREE.Group();
            
            // Flower petals
            const petalGeometry = new THREE.SphereGeometry(0.3 * scale, 8, 6);
            const petalColors = [0xff69b4, 0xff1493, 0xffc0cb, 0xff6347, 0xffd700];
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const petal = new THREE.Mesh(
                    petalGeometry,
                    new THREE.MeshLambertMaterial({ 
                        color: petalColors[Math.floor(Math.random() * petalColors.length)]
                    })
                );
                petal.position.set(
                    Math.cos(angle) * 0.8 * scale,
                    0,
                    Math.sin(angle) * 0.8 * scale
                );
                petal.castShadow = true;
                flowerGroup.add(petal);
            }
            
            // Flower center
            const centerGeometry = new THREE.SphereGeometry(0.4 * scale, 8, 6);
            const center = new THREE.Mesh(
                centerGeometry,
                new THREE.MeshLambertMaterial({ color: 0xffff00 })
            );
            center.castShadow = true;
            flowerGroup.add(center);
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.1 * scale, 0.1 * scale, 2 * scale);
            const stem = new THREE.Mesh(
                stemGeometry,
                new THREE.MeshLambertMaterial({ color: 0x228b22 })
            );
            stem.position.y = -1 * scale;
            stem.castShadow = true;
            flowerGroup.add(stem);
            
            // Leaves
            for (let i = 0; i < 3; i++) {
                const leafGeometry = new THREE.SphereGeometry(0.3 * scale, 6, 4);
                const leaf = new THREE.Mesh(
                    leafGeometry,
                    new THREE.MeshLambertMaterial({ color: 0x32cd32 })
                );
                leaf.scale.set(0.5, 0.1, 1);
                leaf.position.set(
                    (Math.random() - 0.5) * scale,
                    -0.5 * scale - i * 0.3 * scale,
                    (Math.random() - 0.5) * scale
                );
                leaf.rotation.z = Math.random() * 0.5;
                leaf.castShadow = true;
                flowerGroup.add(leaf);
            }
            
            flowerGroup.position.set(x, y, z);
            
            // Add gentle swaying animation
            flowerGroup.userData.originalY = y;
            flowerGroup.userData.swayOffset = Math.random() * Math.PI * 2;
            
            return flowerGroup;
        }
        
        function createFlowerName() {
            // Clear existing flowers
            flowers.forEach(flower => scene.remove(flower));
            flowers = [];
            
            const name = document.getElementById('nameInput').value.toUpperCase() || 'LOVE';
            const letterWidth = 2;
            const startX = -(name.length * letterWidth) / 2;
            
            for (let i = 0; i < name.length; i++) {
                const letter = name[i];
                if (letter === ' ') continue;
                
                const letterFlowers = createLetterFlowers(letter, startX + i * letterWidth, 2, 0);
                letterFlowers.forEach(flower => {
                    flowers.push(flower);
                    scene.add(flower);
                });
            }
        }
        
        function createLetterFlowers(letter, offsetX, offsetY, offsetZ) {
            const flowerPositions = getLetterPositions(letter);
            const letterFlowers = [];
            
            flowerPositions.forEach(pos => {
                const flower = createFlower(
                    pos.x + offsetX,
                    pos.y + offsetY,
                    pos.z + offsetZ,
                    0.8
                );
                letterFlowers.push(flower);
            });
            
            return letterFlowers;
        }
        
        function getLetterPositions(letter) {
            // Simple letter patterns - you can expand this
            const patterns = {
                'A': [{x:-0.5,y:0,z:0}, {x:0.5,y:0,z:0}, {x:-0.3,y:0.5,z:0}, {x:0.3,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0,y:0.3,z:0}],
                'B': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0.3,y:0.25,z:0}, {x:0.3,y:0.75,z:0}],
                'C': [{x:-0.3,y:0,z:0}, {x:-0.3,y:0.5,z:0}, {x:-0.3,y:1,z:0}, {x:0,y:0.1,z:0}, {x:0,y:0.9,z:0}, {x:0.3,y:0.2,z:0}, {x:0.3,y:0.8,z:0}],
                'D': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0,z:0}, {x:0,y:1,z:0}, {x:0.3,y:0.2,z:0}, {x:0.3,y:0.5,z:0}, {x:0.3,y:0.8,z:0}],
                'E': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0.3,y:0,z:0}, {x:0.3,y:1,z:0}],
                'F': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0.3,y:1,z:0}],
                'G': [{x:-0.3,y:0,z:0}, {x:-0.3,y:0.5,z:0}, {x:-0.3,y:1,z:0}, {x:0,y:0.1,z:0}, {x:0,y:0.9,z:0}, {x:0.3,y:0.2,z:0}, {x:0.3,y:0.5,z:0}, {x:0.2,y:0.5,z:0}],
                'H': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:0.5,z:0}, {x:0.5,y:1,z:0}, {x:0,y:0.5,z:0}],
                'I': [{x:0,y:0,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:-0.3,y:0,z:0}, {x:0.3,y:0,z:0}, {x:-0.3,y:1,z:0}, {x:0.3,y:1,z:0}],
                'J': [{x:0.5,y:0.5,z:0}, {x:0.5,y:1,z:0}, {x:0,y:0,z:0}, {x:-0.3,y:0.2,z:0}, {x:0.3,y:1,z:0}, {x:-0.3,y:1,z:0}],
                'K': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0.5,z:0}, {x:0.3,y:0.2,z:0}, {x:0.3,y:0.8,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:1,z:0}],
                'L': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0,z:0}, {x:0.3,y:0,z:0}],
                'M': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:0.5,z:0}, {x:0.5,y:1,z:0}, {x:0,y:0.7,z:0}, {x:-0.2,y:0.8,z:0}, {x:0.2,y:0.8,z:0}],
                'N': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:0.5,z:0}, {x:0.5,y:1,z:0}, {x:0,y:0.5,z:0}, {x:-0.2,y:0.7,z:0}, {x:0.2,y:0.3,z:0}],
                'O': [{x:-0.3,y:0.2,z:0}, {x:-0.3,y:0.5,z:0}, {x:-0.3,y:0.8,z:0}, {x:0.3,y:0.2,z:0}, {x:0.3,y:0.5,z:0}, {x:0.3,y:0.8,z:0}, {x:0,y:0,z:0}, {x:0,y:1,z:0}],
                'P': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0.3,y:0.75,z:0}],
                'Q': [{x:-0.3,y:0.2,z:0}, {x:-0.3,y:0.5,z:0}, {x:-0.3,y:0.8,z:0}, {x:0.3,y:0.2,z:0}, {x:0.3,y:0.5,z:0}, {x:0.3,y:0.8,z:0}, {x:0,y:0,z:0}, {x:0,y:1,z:0}, {x:0.4,y:0.1,z:0}],
                'R': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0,y:0.5,z:0}, {x:0,y:1,z:0}, {x:0.3,y:0.75,z:0}, {x:0.1,y:0.4,z:0}, {x:0.4,y:0.1,z:0}],
                'S': [{x:-0.3,y:0.8,z:0}, {x:0,y:1,z:0}, {x:0.3,y:0.8,z:0}, {x:0,y:0.5,z:0}, {x:-0.3,y:0.2,z:0}, {x:0,y:0,z:0}, {x:0.3,y:0.2,z:0}],
                'T': [{x:-0.4,y:1,z:0}, {x:-0.2,y:1,z:0}, {x:0,y:1,z:0}, {x:0.2,y:1,z:0}, {x:0.4,y:1,z:0}, {x:0,y:0,z:0}, {x:0,y:0.3,z:0}, {x:0,y:0.7,z:0}],
                'U': [{x:-0.5,y:0.3,z:0}, {x:-0.5,y:0.7,z:0}, {x:-0.5,y:1,z:0}, {x:0.5,y:0.3,z:0}, {x:0.5,y:0.7,z:0}, {x:0.5,y:1,z:0}, {x:0,y:0,z:0}, {x:-0.2,y:0.1,z:0}, {x:0.2,y:0.1,z:0}],
                'V': [{x:-0.5,y:0.7,z:0}, {x:-0.5,y:1,z:0}, {x:0.5,y:0.7,z:0}, {x:0.5,y:1,z:0}, {x:-0.2,y:0.3,z:0}, {x:0.2,y:0.3,z:0}, {x:0,y:0,z:0}],
                'W': [{x:-0.5,y:0,z:0}, {x:-0.5,y:0.5,z:0}, {x:-0.5,y:1,z:0}, {x:0.5,y:0,z:0}, {x:0.5,y:0.5,z:0}, {x:0.5,y:1,z:0}, {x:0,y:0.3,z:0}, {x:-0.2,y:0.2,z:0}, {x:0.2,y:0.2,z:0}],
                'X': [{x:-0.4,y:0.1,z:0}, {x:-0.2,y:0.3,z:0}, {x:0,y:0.5,z:0}, {x:0.2,y:0.7,z:0}, {x:0.4,y:0.9,z:0}, {x:0.4,y:0.1,z:0}, {x:0.2,y:0.3,z:0}, {x:-0.2,y:0.7,z:0}, {x:-0.4,y:0.9,z:0}],
                'Y': [{x:-0.4,y:0.8,z:0}, {x:-0.2,y:0.6,z:0}, {x:0,y:0.5,z:0}, {x:0.2,y:0.6,z:0}, {x:0.4,y:0.8,z:0}, {x:0,y:0,z:0}, {x:0,y:0.25,z:0}, {x:-0.4,y:1,z:0}, {x:0.4,y:1,z:0}],
                'Z': [{x:-0.4,y:1,z:0}, {x:-0.1,y:1,z:0}, {x:0.2,y:1,z:0}, {x:0.4,y:1,z:0}, {x:0.1,y:0.7,z:0}, {x:-0.1,y:0.3,z:0}, {x:-0.4,y:0,z:0}, {x:-0.1,y:0,z:0}, {x:0.2,y:0,z:0}, {x:0.4,y:0,z:0}]
            };
            
            return patterns[letter] || [{x:0,y:0.5,z:0}]; // Default to single flower if letter not found
        }
        
        function createFlowerHeart() {
            // Clear existing flowers
            flowers.forEach(flower => scene.remove(flower));
            flowers = [];
            
            // Create heart shape with flowers
            const heartPositions = [];
            const scale = 3;
            
            // Generate heart shape points
            for (let t = 0; t < Math.PI * 2; t += 0.3) {
                const x = scale * (16 * Math.pow(Math.sin(t), 3));
                const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                heartPositions.push({x: x/10, y: y/10 + 2, z: 0});
                
                // Add depth layers for walkable structure
                for (let depth = -1; depth <= 1; depth += 0.5) {
                    if (depth !== 0) {
                        heartPositions.push({x: x/10, y: y/10 + 2, z: depth});
                    }
                }
            }
            
            // Add inner flowers for a fuller heart
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 2;
                heartPositions.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius + 2,
                    z: (Math.random() - 0.5) * 2
                });
            }
            
            heartPositions.forEach(pos => {
                const flower = createFlower(pos.x, pos.y, pos.z, 0.6);
                flowers.push(flower);
                scene.add(flower);
            });
        }
        
        function setupControls() {
            const onKeyDown = function(event) {
                switch(event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        break;
                }
            };
            
            const onKeyUp = function(event) {
                switch(event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            };
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse look
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === renderer.domElement) {
                    mouseX += event.movementX * 0.002;
                    mouseY += event.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                    
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = -mouseX;
                    camera.rotation.x = -mouseY;
                }
            });
            
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Movement
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.z = Number(moveBackward) - Number(moveForward);
            direction.normalize();
            
            if (moveForward || moveBackward) velocity.z -= direction.z * 0.1;
            if (moveLeft || moveRight) velocity.x -= direction.x * 0.1;
            
            velocity.multiplyScalar(0.9); // Damping
            
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();
            
            camera.position.addScaledVector(right, -velocity.x);
            camera.position.addScaledVector(forward, -velocity.z);
            
            // Animate flowers (gentle swaying)
            const time = Date.now() * 0.001;
            flowers.forEach(flower => {
                if (flower.userData.originalY !== undefined) {
                    flower.position.y = flower.userData.originalY + Math.sin(time + flower.userData.swayOffset) * 0.1;
                    flower.rotation.z = Math.sin(time + flower.userData.swayOffset) * 0.05;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function enterVR() {
            if (navigator.xr) {
                navigator.xr.requestSession('immersive-vr').then((session) => {
                    renderer.xr.setSession(session);
                }).catch(err => {
                    alert('VR not supported or not available. Make sure you\'re using a VR-capable device.');
                });
            } else {
                alert('WebXR not supported in this browser. Try using the Meta Quest browser or Chrome with WebXR support.');
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize the experience
        init();
    </script>
</body>
</html>
</body>
</html>
